using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace dotweave.Generator;

internal static class Emitter
{
    // Bump this when generated code shape changes.
    private const string GeneratorVersion = "1.0.0";

    public static string Generate(ImmutableArray<InvocationInfo> candidates)
    {
        var sb = new StringBuilder(candidates.Length * 512);
        var hasTracing = candidates.Any(c => c.EmitTracing);
        var hasMetrics = candidates.Any(c => c.EmitMetrics);
        var hasDuration = candidates.Any(c => c.EmitMetrics && c.EmitDuration);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS9270 // InterceptsLocationAttribute is experimental");
        sb.AppendLine();
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]");
        sb.AppendLine("    file sealed class InterceptsLocationAttribute : Attribute");
        sb.AppendLine("    {");
        sb.AppendLine("        public InterceptsLocationAttribute(string filePath, int line, int column) { }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("namespace dotweave.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
        sb.AppendLine("    file static class TracedInterceptors");
        sb.AppendLine("    {");

        if (hasTracing)
        {
            sb.AppendLine($"        private static readonly System.Diagnostics.ActivitySource ActivitySource =");
            sb.AppendLine($"            new(\"dotweave.Traced\", \"{GeneratorVersion}\");");
        }

        if (hasMetrics)
        {
            sb.AppendLine($"        private static readonly System.Diagnostics.Metrics.Meter Meter =");
            sb.AppendLine($"            new(\"dotweave.Metrics\", \"{GeneratorVersion}\");");
            sb.AppendLine();
            EmitMetricFields(sb, candidates);
        }

        if (hasTracing || hasMetrics)
        {
            sb.AppendLine();
        }

        // Emit a portable elapsed-time helper so generated code works on .NET 7+ and earlier.
        if (hasDuration)
        {
            sb.AppendLine("        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("        private static double GetElapsedMs(long startTimestamp)");
            sb.AppendLine("        {");
            sb.AppendLine("            return (System.Diagnostics.Stopwatch.GetTimestamp() - startTimestamp) * 1000.0 / System.Diagnostics.Stopwatch.Frequency;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        for (int i = 0; i < candidates.Length; i++)
        {
            var c = candidates[i];
            EmitInterceptorMethod(sb, c, i, candidates);
            if (i < candidates.Length - 1)
                sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Emits one set of metric fields per unique metric name, not per call site.
    /// Only emits instruments that are actually requested.
    /// </summary>
    private static void EmitMetricFields(StringBuilder sb, ImmutableArray<InvocationInfo> candidates)
    {
        // Collect unique metric configs. For a given metric name, we take the union
        // of requested instruments across all call sites (if one site wants Calls
        // and another wants Duration, we emit both).
        var configs = new Dictionary<string, MetricConfig>();
        foreach (var c in candidates)
        {
            if (!c.EmitMetrics)
                continue;

            if (!configs.TryGetValue(c.MetricName, out var cfg))
            {
                cfg = new MetricConfig();
                configs[c.MetricName] = cfg;
            }
            cfg.EmitCalls |= c.EmitCalls;
            cfg.EmitDuration |= c.EmitDuration;
            cfg.EmitInFlight |= c.EmitInFlight;
        }

        foreach (var kvp in configs)
        {
            var metricName = kvp.Key;
            var cfg = kvp.Value;
            var fieldSuffix = MetricFieldSuffix(metricName);
            var escapedName = metricName.Replace("\"", "\\\"");

            if (cfg.EmitCalls)
            {
                sb.AppendLine($"        private static readonly System.Diagnostics.Metrics.Counter<long> Calls_{fieldSuffix} =");
                sb.AppendLine($"            Meter.CreateCounter<long>(\"{escapedName}.calls\", description: \"Total invocations of {escapedName}\");");
            }
            if (cfg.EmitDuration)
            {
                sb.AppendLine($"        private static readonly System.Diagnostics.Metrics.Histogram<double> DurationMs_{fieldSuffix} =");
                sb.AppendLine($"            Meter.CreateHistogram<double>(\"{escapedName}.duration\", unit: \"ms\", description: \"Duration of {escapedName} invocations\");");
            }
            if (cfg.EmitInFlight)
            {
                sb.AppendLine($"        private static readonly System.Diagnostics.Metrics.UpDownCounter<long> InFlight_{fieldSuffix} =");
                sb.AppendLine($"            Meter.CreateUpDownCounter<long>(\"{escapedName}.inflight\", description: \"Concurrent executions of {escapedName}\");");
            }
            sb.AppendLine();
        }
    }

    private class MetricConfig
    {
        public bool EmitCalls;
        public bool EmitDuration;
        public bool EmitInFlight;
    }

    /// <summary>
    /// Produces a safe C# identifier suffix from a metric name.
    /// Replaces non-alphanumeric characters with underscores and prepends
    /// an underscore if the result starts with a digit.
    /// </summary>
    private static string MetricFieldSuffix(string metricName)
    {
        var sb = new StringBuilder(metricName.Length);
        foreach (var ch in metricName)
        {
            sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }
        // Ensure the suffix doesn't start with a digit (invalid C# identifier)
        if (sb.Length > 0 && char.IsDigit(sb[0]))
            sb.Insert(0, '_');
        return sb.ToString();
    }

    /// <summary>
    /// Determines if a parameter name is a C# keyword and needs the @ prefix.
    /// </summary>
    private static bool IsCSharpKeyword(string name) =>
        SyntaxFacts.GetKeywordKind(name) != SyntaxKind.None ||
        SyntaxFacts.GetContextualKeywordKind(name) != SyntaxKind.None;

    /// <summary>
    /// Returns the parameter name, prefixed with @ only if it's a C# keyword.
    /// </summary>
    private static string SafeName(string name) =>
        IsCSharpKeyword(name) ? $"@{name}" : name;

    /// <summary>
    /// Builds the tag array expression for metric Add/Record calls.
    /// Combines the built-in "status" tag with any user-defined custom tags.
    /// Returns something like: new System.Collections.Generic.KeyValuePair&lt;string, object?&gt;("status", "ok"), new ...("endpoint", "greeting")
    /// </summary>
    private static string BuildTagArgs(InvocationInfo c, string statusValue)
    {
        var parts = new List<string>();
        parts.Add($"new System.Collections.Generic.KeyValuePair<string, object?>(\"status\", \"{statusValue}\")");

        foreach (var tag in c.CustomTags)
        {
            var eqIdx = tag.IndexOf('=');
            if (eqIdx <= 0) continue;
            var key = tag.Substring(0, eqIdx).Replace("\"", "\\\"");
            var val = tag.Substring(eqIdx + 1).Replace("\"", "\\\"");
            parts.Add($"new System.Collections.Generic.KeyValuePair<string, object?>(\"{key}\", \"{val}\")");
        }

        return string.Join(", ", parts);
    }

    /// <summary>
    /// Builds the tag array expression for instruments that don't have a status tag (e.g. InFlight).
    /// </summary>
    private static string BuildCustomTagArgs(InvocationInfo c)
    {
        if (c.CustomTags.IsDefaultOrEmpty)
            return "";

        var parts = new List<string>();
        foreach (var tag in c.CustomTags)
        {
            var eqIdx = tag.IndexOf('=');
            if (eqIdx <= 0) continue;
            var key = tag.Substring(0, eqIdx).Replace("\"", "\\\"");
            var val = tag.Substring(eqIdx + 1).Replace("\"", "\\\"");
            parts.Add($"new System.Collections.Generic.KeyValuePair<string, object?>(\"{key}\", \"{val}\")");
        }

        return parts.Count > 0 ? ", " + string.Join(", ", parts) : "";
    }

    private static void EmitInterceptorMethod(
        StringBuilder sb, InvocationInfo c, int index, ImmutableArray<InvocationInfo> candidates)
    {
        // Use verbatim string for path -- no manual escaping needed.
        sb.AppendLine($"        [System.Runtime.CompilerServices.InterceptsLocation(@\"{c.FilePath}\", {c.Line}, {c.Column})]");

        var paramList = new StringBuilder();
        var argList = new StringBuilder();

        if (!c.IsStatic && c.InstanceType is not null)
        {
            paramList.Append($"this {c.InstanceType} __this");
            if (c.Parameters.Length > 0)
                paramList.Append(", ");
        }

        for (int i = 0; i < c.Parameters.Length; i++)
        {
            var p = c.Parameters[i];
            var refMod = p.RefKind switch
            {
                RefKind.Ref => "ref ",
                RefKind.Out => "out ",
                RefKind.In => "in ",
                RefKind.RefReadOnlyParameter => "ref readonly ",
                _ => ""
            };

            var paramsMod = p.IsParams ? "params " : "";

            if (i > 0)
            {
                paramList.Append(", ");
                argList.Append(", ");
            }

            var safeName = SafeName(p.Name);
            var defaultSuffix = p.HasDefaultValue ? $" = {p.DefaultValueExpression}" : "";
            paramList.Append($"{paramsMod}{refMod}{p.Type} {safeName}{defaultSuffix}");
            argList.Append($"{refMod}{safeName}");
        }

        var callTarget = c.IsStatic ? c.ContainingType : "__this";
        var spanName = c.SpanName.Replace("\"", "\\\"");

        if (c.IsAsync && c.IsValueTask)
            EmitValueTaskMethod(sb, c, index, paramList.ToString(), argList.ToString(), callTarget, spanName);
        else if (c.IsAsync)
            EmitAsyncMethod(sb, c, index, paramList.ToString(), argList.ToString(), callTarget, spanName);
        else if (c.ReturnsVoid)
            EmitVoidMethod(sb, c, index, paramList.ToString(), argList.ToString(), callTarget, spanName);
        else
            EmitSyncMethod(sb, c, index, paramList.ToString(), argList.ToString(), callTarget, spanName);
    }

    /// <summary>
    /// Emits an async interceptor for Task / Task&lt;T&gt; methods.
    /// </summary>
    private static void EmitAsyncMethod(
        StringBuilder sb,
        InvocationInfo c,
        int index,
        string paramList,
        string argList,
        string callTarget,
        string spanName)
    {
        var hasReturnValue = c.HasAsyncReturnValue;

        sb.AppendLine($"        public static async {c.ReturnType} Intercepted_{c.MethodName}_{index}({paramList})");
        sb.AppendLine("        {");
        EmitMethodPrologue(sb, c, spanName);
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        if (hasReturnValue)
        {
            sb.AppendLine($"                var __result = await {callTarget}.{c.MethodName}({argList});");
            EmitMetricsOnSuccess(sb, c, "__result");
            sb.AppendLine("                return __result;");
        }
        else
        {
            sb.AppendLine($"                await {callTarget}.{c.MethodName}({argList});");
            EmitMetricsOnSuccess(sb, c, null);
        }

        sb.AppendLine("            }");
        EmitCatchBlock(sb, c);
        EmitFinallyBlock(sb, c);
        sb.AppendLine("        }");
    }

    /// <summary>
    /// Emits a ValueTask / ValueTask&lt;T&gt; interceptor with a synchronous fast-path
    /// to avoid state machine allocation when the task completes synchronously.
    /// </summary>
    private static void EmitValueTaskMethod(
        StringBuilder sb,
        InvocationInfo c,
        int index,
        string paramList,
        string argList,
        string callTarget,
        string spanName)
    {
        var hasReturnValue = c.HasAsyncReturnValue;
        var fieldSuffix = MetricFieldSuffix(c.MetricName);

        // The outer method: checks synchronous completion, delegates to slow path if needed.
        sb.AppendLine($"        public static {c.ReturnType} Intercepted_{c.MethodName}_{index}({paramList})");
        sb.AppendLine("        {");

        if (c.EmitTracing)
        {
            sb.AppendLine($"            var __activity = ActivitySource.StartActivity(\"{spanName}\");");
        }
        if (c.EmitMetrics && c.EmitDuration)
        {
            sb.AppendLine("            var __startTimestamp = System.Diagnostics.Stopwatch.GetTimestamp();");
        }
        if (c.EmitMetrics && c.EmitInFlight)
        {
            sb.AppendLine($"            InFlight_{fieldSuffix}.Add(1{BuildCustomTagArgs(c)});");
        }

        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine($"                var __task = {callTarget}.{c.MethodName}({argList});");
        sb.AppendLine("                if (__task.IsCompletedSuccessfully)");
        sb.AppendLine("                {");

        // Fast path: synchronous completion -- no state machine allocation.
        EmitInlineMetricsSuccess(sb, c, fieldSuffix, hasReturnValue ? "__task.Result" : null);
        if (c.EmitTracing)
        {
            sb.AppendLine("                    __activity?.Dispose();");
        }

        if (hasReturnValue)
            sb.AppendLine("                    return new " + c.ReturnType + "(__task.Result);");
        else
            sb.AppendLine("                    return default;");

        sb.AppendLine("                }");

        // Slow path: must await.
        var slowArgs = new StringBuilder();
        slowArgs.Append("__task");
        if (c.EmitTracing)
            slowArgs.Append(", __activity");
        if (c.EmitMetrics && c.EmitDuration)
            slowArgs.Append(", __startTimestamp");

        sb.AppendLine($"                return new {c.ReturnType}(AwaitSlowPath_{index}({slowArgs}));");

        sb.AppendLine("            }");
        sb.AppendLine("            catch (System.Exception __ex)");
        sb.AppendLine("            {");
        if (c.EmitTracing)
        {
            EmitTracingError(sb, "__activity");
            sb.AppendLine("                __activity?.Dispose();");
        }
        EmitInlineMetricsError(sb, c, fieldSuffix);
        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Emit the async slow path helper method.
        EmitValueTaskSlowPath(sb, c, index, hasReturnValue, fieldSuffix, spanName);
    }

    private static void EmitValueTaskSlowPath(
        StringBuilder sb,
        InvocationInfo c,
        int index,
        bool hasReturnValue,
        string fieldSuffix,
        string spanName)
    {
        // Determine parameter list for the slow path
        var slowParams = new StringBuilder();
        slowParams.Append($"{c.ReturnType} __task");
        if (c.EmitTracing)
            slowParams.Append(", System.Diagnostics.Activity? __activity");
        if (c.EmitMetrics && c.EmitDuration)
            slowParams.Append(", long __startTimestamp");

        var innerReturnType = c.InnerReturnType ?? "object";
        var returnType = hasReturnValue
            ? $"async System.Threading.Tasks.Task<{innerReturnType}>"
            : "async System.Threading.Tasks.Task";

        sb.AppendLine($"        private static {returnType} AwaitSlowPath_{index}({slowParams})");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        if (hasReturnValue)
        {
            sb.AppendLine("                var __result = await __task;");
            EmitInlineMetricsSuccess(sb, c, fieldSuffix, "__result");
            sb.AppendLine("                return __result;");
        }
        else
        {
            sb.AppendLine("                await __task;");
            EmitInlineMetricsSuccess(sb, c, fieldSuffix, null);
        }

        sb.AppendLine("            }");
        sb.AppendLine("            catch (System.Exception __ex)");
        sb.AppendLine("            {");
        if (c.EmitTracing)
        {
            EmitTracingError(sb, "__activity");
        }
        EmitInlineMetricsError(sb, c, fieldSuffix);
        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        if (c.EmitTracing)
            sb.AppendLine("                __activity?.Dispose();");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private static void EmitVoidMethod(
        StringBuilder sb,
        InvocationInfo c,
        int index,
        string paramList,
        string argList,
        string callTarget,
        string spanName)
    {
        sb.AppendLine($"        public static void Intercepted_{c.MethodName}_{index}({paramList})");
        sb.AppendLine("        {");
        EmitMethodPrologue(sb, c, spanName);
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine($"                {callTarget}.{c.MethodName}({argList});");
        EmitMetricsOnSuccess(sb, c, null);
        sb.AppendLine("            }");
        EmitCatchBlock(sb, c);
        EmitFinallyBlock(sb, c);
        sb.AppendLine("        }");
    }

    private static void EmitSyncMethod(
        StringBuilder sb,
        InvocationInfo c,
        int index,
        string paramList,
        string argList,
        string callTarget,
        string spanName)
    {
        sb.AppendLine($"        public static {c.ReturnType} Intercepted_{c.MethodName}_{index}({paramList})");
        sb.AppendLine("        {");
        EmitMethodPrologue(sb, c, spanName);
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine($"                var __result = {callTarget}.{c.MethodName}({argList});");
        EmitMetricsOnSuccess(sb, c);
        sb.AppendLine("                return __result;");
        sb.AppendLine("            }");
        EmitCatchBlock(sb, c);
        EmitFinallyBlock(sb, c);
        sb.AppendLine("        }");
    }

    private static void EmitMethodPrologue(StringBuilder sb, InvocationInfo c, string spanName)
    {
        if (c.EmitTracing)
        {
            sb.AppendLine($"            using var __activity = ActivitySource.StartActivity(\"{spanName}\");");
        }

        if (c.EmitMetrics)
        {
            var fieldSuffix = MetricFieldSuffix(c.MetricName);
            if (c.EmitDuration)
            {
                sb.AppendLine("            var __startTimestamp = System.Diagnostics.Stopwatch.GetTimestamp();");
            }
            if (c.EmitInFlight)
            {
                sb.AppendLine($"            InFlight_{fieldSuffix}.Add(1{BuildCustomTagArgs(c)});");
            }
        }
    }

    private static void EmitMetricsOnSuccess(StringBuilder sb, InvocationInfo c, string? resultExpr = "__result")
    {
        if (!c.EmitMetrics)
            return;

        var fieldSuffix = MetricFieldSuffix(c.MetricName);
        EmitInlineMetricsSuccess(sb, c, fieldSuffix, resultExpr);
    }

    private static void EmitMetricsOnError(StringBuilder sb, InvocationInfo c)
    {
        if (!c.EmitMetrics)
            return;

        var fieldSuffix = MetricFieldSuffix(c.MetricName);
        EmitInlineMetricsError(sb, c, fieldSuffix);
    }

    /// <summary>
    /// Emits metric recording for the success path. Used by both the main method helpers
    /// and the ValueTask inline paths.
    /// Does NOT emit InFlight decrement -- that belongs in the finally block.
    /// When <see cref="InvocationInfo.ErrorWhenPredicate"/> is set and a result variable
    /// is available, the generated code calls the predicate to determine status.
    /// When the predicate detects an error and tracing is enabled, the span is also
    /// marked with <c>ActivityStatusCode.Error</c>.
    /// </summary>
    private static void EmitInlineMetricsSuccess(StringBuilder sb, InvocationInfo c, string fieldSuffix, string? resultExpr = "__result")
    {
        if (!c.EmitMetrics)
            return;

        if (c.ErrorWhenPredicate is not null && resultExpr is not null)
        {
            // Predicate-based status: call the user's static bool method
            var okTags = BuildTagArgs(c, "ok");
            var errorTags = BuildTagArgs(c, "error");
            sb.AppendLine($"                if ({c.ErrorWhenPredicate}({resultExpr}))");
            sb.AppendLine("                {");
            if (c.EmitTracing)
            {
                sb.AppendLine("                    __activity?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, \"ErrorWhen predicate returned true\");");
            }
            if (c.EmitCalls)
                sb.AppendLine($"                    Calls_{fieldSuffix}.Add(1, {errorTags});");
            if (c.EmitDuration)
                sb.AppendLine($"                    DurationMs_{fieldSuffix}.Record(GetElapsedMs(__startTimestamp), {errorTags});");
            sb.AppendLine("                }");
            sb.AppendLine("                else");
            sb.AppendLine("                {");
            if (c.EmitCalls)
                sb.AppendLine($"                    Calls_{fieldSuffix}.Add(1, {okTags});");
            if (c.EmitDuration)
                sb.AppendLine($"                    DurationMs_{fieldSuffix}.Record(GetElapsedMs(__startTimestamp), {okTags});");
            sb.AppendLine("                }");
        }
        else
        {
            var okTags = BuildTagArgs(c, "ok");
            if (c.EmitCalls)
                sb.AppendLine($"                Calls_{fieldSuffix}.Add(1, {okTags});");
            if (c.EmitDuration)
                sb.AppendLine($"                DurationMs_{fieldSuffix}.Record(GetElapsedMs(__startTimestamp), {okTags});");
        }
    }

    /// <summary>
    /// Emits metric recording for the error path.
    /// Does NOT emit InFlight decrement -- that belongs in the finally block.
    /// </summary>
    private static void EmitInlineMetricsError(StringBuilder sb, InvocationInfo c, string fieldSuffix)
    {
        if (!c.EmitMetrics)
            return;

        var errorTags = BuildTagArgs(c, "error");
        if (c.EmitCalls)
            sb.AppendLine($"                Calls_{fieldSuffix}.Add(1, {errorTags});");
        if (c.EmitDuration)
            sb.AppendLine($"                DurationMs_{fieldSuffix}.Record(GetElapsedMs(__startTimestamp), {errorTags});");
    }

    private static void EmitTracingError(StringBuilder sb, string activityVar)
    {
        sb.AppendLine($"                {activityVar}?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, __ex.Message);");
        sb.AppendLine($"                {activityVar}?.AddEvent(new System.Diagnostics.ActivityEvent(\"exception\",");
        sb.AppendLine("                    tags: new System.Diagnostics.ActivityTagsCollection");
        sb.AppendLine("                    {");
        sb.AppendLine("                        { \"exception.type\", __ex.GetType().FullName },");
        sb.AppendLine("                        { \"exception.message\", __ex.Message },");
        sb.AppendLine("                        { \"exception.stacktrace\", __ex.ToString() }");
        sb.AppendLine("                    }));");
    }

    private static void EmitCatchBlock(StringBuilder sb, InvocationInfo c)
    {
        sb.AppendLine("            catch (System.Exception __ex)");
        sb.AppendLine("            {");

        if (c.EmitTracing)
        {
            EmitTracingError(sb, "__activity");
        }

        EmitMetricsOnError(sb, c);

        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
    }

    /// <summary>
    /// Emits a finally block that decrements the InFlight counter.
    /// This ensures the counter is always decremented, even if metrics
    /// recording in the success/error paths throws.
    /// </summary>
    private static void EmitFinallyBlock(StringBuilder sb, InvocationInfo c)
    {
        if (!c.EmitMetrics || !c.EmitInFlight)
            return;

        var fieldSuffix = MetricFieldSuffix(c.MetricName);
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        sb.AppendLine($"                InFlight_{fieldSuffix}.Add(-1{BuildCustomTagArgs(c)});");
        sb.AppendLine("            }");
    }
}
